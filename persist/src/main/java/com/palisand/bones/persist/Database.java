package com.palisand.bones.persist;

import java.lang.annotation.ElementType;
import java.lang.annotation.Repeatable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.RecordComponent;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Time;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.UUID;
import java.util.WeakHashMap;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import com.palisand.bones.persist.CommandScheme.Metadata;
import com.palisand.bones.persist.CommandScheme.Metadata.DbIndex;
import com.palisand.bones.persist.CommandScheme.Metadata.DbTable;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;

/**
 * This class is the starting point for using the bones persist framework. It is thread safe but
 * does not need to be cached because it is very light weight. Any cache is linked to the connection
 * that you need to provide in all methods. When the connection is garbage collected the cache will
 * be cleared.
 * 
 * See the README.md for more information
 */
public class Database {

  @FunctionalInterface
  public interface Transaction {
    void perform() throws Exception;
  }

  @FunctionalInterface
  public interface TransactionWithResult {
    Object perform() throws Exception;
  }

  @FunctionalInterface
  interface RsGetter {
    Object get(ResultSet rs, int pos) throws SQLException;
  }

  @FunctionalInterface
  interface StmtSetter {
    void set(PreparedStatement stmt, int pos, Object value) throws SQLException;
  }

  interface DbClassInner extends Cloneable {
    void setEntity(DbClass entity);

    Object clone() throws CloneNotSupportedException;
  }

  private static final Class<?>[] SUPPORTED_OBJECT_TYPES = {String.class, Boolean.class,
      Integer.class, Long.class, Double.class, Float.class, Short.class, BigDecimal.class,
      BigInteger.class, LocalDate.class, LocalDateTime.class, Calendar.class, Date.class,
      OffsetDateTime.class, Time.class, UUID.class, Clob.class, Blob.class, byte[].class};
  private static final Map<Connection, CommandScheme> COMMAND_SCHEMES =
      Collections.synchronizedMap(new WeakHashMap<>());

  static Class<?> getGenericType(Type type, int position) {
    try {
      ParameterizedType pType = (ParameterizedType) type;
      return (Class<?>) pType.getActualTypeArguments()[position];
    } catch (Exception ex) {
      // ignore
    }
    return null;
  }

  /**
   * annotation to specify that a field is (part of) the primary key
   */
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.FIELD)
  public @interface Id {
    /**
     * Indicates the field should be generated by the database
     * 
     * @return
     */
    boolean generated() default false;
  }

  /**
   * Specifies a field to hold the version of the object in the optimistic locking strategy
   */
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.FIELD)
  public @interface Version {
  }

  /**
   * Specifies a field to be a foreign key (or its opposite). It is not necessary to specify this
   * annotation on both roles.
   */
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.FIELD)
  public @interface Relation {
    String opposite();
  }

  /**
   * The annotation specifies that a field is included in a index. The value should indicate the
   * name of the index. If multiple index annotations on different fields have the same name they
   * will result in one index with multiple fields. The order of the fields as specified in the
   * source file of the persistent class.
   */
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.FIELD)
  @Repeatable(Indices.class)
  public @interface Index {
    String value();

    boolean unique() default false;
  }

  /**
   * Annotation used when a field is included in more than one index
   */
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.FIELD)
  public @interface Indices {
    Index[] value();
  }

  /**
   * Use this annotation on classes that should not have its own table but its fields should be
   * inherited by its subclasses and included in their corresponding tables.
   */
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.TYPE)
  public @interface Mapped {
  }

  /**
   * Use this annotation on fields that are not persistent
   */
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.FIELD)
  public @interface DontPersist {
  }

  /**
   * This annotation can be used to specify different names or specific lengths and scales for
   * fields. The values will only be used when they are relevant for the type of the field
   */
  @Retention(RetentionPolicy.RUNTIME)
  @Target({ElementType.FIELD, ElementType.TYPE})
  public @interface Db {
    /**
     * specifies a explicit name for the table or field
     * 
     * @return
     */
    String name()

    default "";

    /**
     * specifies a specific size of a field. Only valid for some types. This may be database
     * specific
     * 
     * @return
     */
    int size()

    default 0;

    /**
     * specifies the scale of a field. Only valid for some types. This may be database specific
     * 
     * @return
     */
    int scale()

    default 0;
  }

  @Setter
  @Getter
  @RequiredArgsConstructor
  static class DbSearchMethod implements DbClassInner {
    private String name;
    private List<DbField> fields = new ArrayList<>();
    private boolean unique = false;
    private DbClass entity;

    @Override
    public Object clone() throws CloneNotSupportedException {
      return super.clone();
    }

    @Override
    public String toString() {
      return getName();
    }
  }

  @Setter
  @Getter
  @RequiredArgsConstructor
  static class DbRole implements DbClassInner {
    private Field field;
    private DbSearchMethod foreignKey;
    private Class<?> type;
    private DbRole opposite;
    private Method getter;
    private Method setter;
    private Id id = null;
    private DbClass entity;

    @Override
    public String toString() {
      return getName();
    }

    @Override
    public Object clone() throws CloneNotSupportedException {
      return super.clone();
    }

    String getName() {
      if (field == null) {
        return foreignKey.getName();
      }
      return field.getName();
    }

    boolean isForeignKey() {
      // TODO: this excludes one-to-one associations at this time
      return !isMany();
    }

    Relation getRelation() {
      return field.getAnnotation(Relation.class);
    }

    boolean isMany() {
      return Collection.class.isAssignableFrom(field.getType());
    }

    boolean isPrimaryKeyRole() {
      return id != null;
    }

    Object get(Object owner) throws SQLException {
      try {
        return getter.invoke(owner);
      } catch (Exception ex) {
        if (ex.getCause() != null) {
          ex = (Exception) ex.getCause();
        }
        throw new SQLException("Could not get value of field " + field);
      }
    }

    @SuppressWarnings("unchecked")
    void set(Object owner, Object value) throws SQLException {
      try {
        if (isMany()) {
          Collection<Object> col = (Collection<Object>) getter.invoke(owner);
          if (col == null) {
            if (field.getType() == List.class || field.getType() == Collection.class) {
              col = new ArrayList<>();
            } else if (field.getType() == Set.class) {
              col = new HashSet<>();
            } else {
              col = (Collection<Object>) field.getType().getConstructor().newInstance();
            }
            setter.invoke(owner, col);
          } else {
            col.clear();
          }
          if (value != null) {
            col.addAll((Collection<Object>) value);
          }
        } else {
          setter.invoke(owner, value);
        }
      } catch (Exception ex) {
        if (ex.getCause() != null) {
          ex = (Exception) ex.getCause();
        }
        throw new SQLException("Could not set value of field " + field, ex);
      }
    }

    DbSearchMethod getForeignKey() throws SQLException {
      if (foreignKey == null) {
        DbClass entity = Database.getDbClass(type);
        foreignKey = new DbSearchMethod();
        foreignKey.setEntity(getEntity());
        foreignKey.setName(getEntity().getName() + '_' + getName());
        foreignKey.setUnique(false);
        entity.getPrimaryKey().getFields().forEach(field -> {
          DbForeignKeyField copy = new DbForeignKeyField();
          copy.setEntity(getEntity());
          copy.setName(getName() + '_' + field.getName());
          copy.setRsGetter(field.getRsGetter());
          copy.setStmtSetter(field.getStmtSetter());
          copy.setType(field.getType());
          copy.setPrimaryKeyField(field);
          copy.setRole(this);
          foreignKey.getFields().add(copy);
        });
      }
      return foreignKey;
    }

    DbRole getOpposite() throws SQLException {
      if (opposite == null) {
        Relation relation = getRelation();
        DbClass other = Database.getDbClass(type);
        if (other != null) {
          if (relation != null) {
            for (DbRole role : other.getForeignKeys()) {
              if (role.getName().equals(relation.opposite())) {
                opposite = role;
                break;
              }
            }
            for (DbRole role : other.getLinks()) {
              if (role.getName().equals(relation.opposite())) {
                opposite = role;
                break;
              }
            }
            if (opposite == null) {
              throw new SQLException("Relation " + getName() + " points to not existing opposite "
                  + relation.opposite());
            }
          } else {
            for (DbRole role : other.getForeignKeys()) {
              relation = role.getRelation();
              if (relation != null && relation.opposite().equals(getName())) {
                opposite = role;
                break;
              }
            }
            if (opposite == null) {
              for (DbRole role : other.getLinks()) {
                relation = role.getRelation();
                if (relation != null && relation.opposite().equals(getName())) {
                  opposite = role;
                  break;
                }
              }
            }
          }
        }
      }
      return opposite;
    }

    String getTablename() throws SQLException {
      DbClass entity = Database.getDbClass(getType());
      return getName() + '_' + entity.getName();
    }

    DbRole getFirst() throws SQLException {
      DbRole opposite = getOpposite();
      if (opposite != null) {
        if (getName().compareTo(opposite.getName()) > 0) {
          return opposite;
        }
      }
      return this;
    }

    DbRole getSecond() throws SQLException {
      return getFirst().getOpposite();
    }

  }

  @Setter
  @Getter
  @RequiredArgsConstructor
  static class DbField implements DbClassInner {
    private Field field;
    private Method getter;
    private Method setter;
    private boolean nullable = true;
    private Id id;
    private Version version;
    private RsGetter rsGetter;
    private StmtSetter stmtSetter;
    private Function<Object, Object> incrementer = null;
    private int size = 0;
    private int scale = 0;
    private String name = null;
    private DbClass entity;

    @Override
    public String toString() {
      return getName();
    }

    @Override
    public Object clone() throws CloneNotSupportedException {
      return super.clone();
    }

    public String getName() {
      if (name == null) {
        return field.getName();
      }
      return name;
    }

    Class<?> getType() {
      return getter.getReturnType();
    }

    boolean isGenerated() {
      return id == null ? false : id.generated();
    }

    boolean isVersion() {
      return version != null;
    }

    Object get(Object owner) throws SQLException {
      try {
        return getter.invoke(owner);
      } catch (Exception ex) {
        if (ex.getCause() != null) {
          ex = (Exception) ex.getCause();
        }
        throw new SQLException("Could not get value of field " + field);
      }
    }

    Object inc(Object owner) throws SQLException {
      Object oldVersion = get(owner);
      set(owner, incrementer.apply(oldVersion));
      return oldVersion;
    }

    void set(Object owner, Object value) throws SQLException {
      try {
        setter.invoke(owner, value);
      } catch (Exception ex) {
        if (ex.getCause() != null) {
          ex = (Exception) ex.getCause();
        }
        throw new SQLException("Could not set value of field " + field + " to " + value, ex);
      }
    }

    Object rsGet(ResultSet rs, int pos) throws SQLException {
      return rsGetter.get(rs, pos);
    }

    void stmtSet(PreparedStatement stmt, int pos, Object value) throws SQLException {
      stmtSetter.set(stmt, pos, value);
    }
  }

  @Getter
  @Setter
  @RequiredArgsConstructor
  static class DbForeignKeyField extends DbField implements DbClassInner {
    private String name;
    private Class<?> type;
    private DbRole role;
    private DbField primaryKeyField;

    @Override
    public Object clone() throws CloneNotSupportedException {
      return super.clone();
    }

    @Override
    Object get(Object owner) throws SQLException {
      Object other = role.get(owner);
      if (other != null) {
        return primaryKeyField.get(other);
      }
      return null;
    }

    @Override
    Object rsGet(ResultSet rs, int pos) throws SQLException {
      return primaryKeyField.rsGet(rs, pos);
    }

    void set(Object owner, Object value) throws SQLException {
      if (value == null) {
        role.set(owner, null);
      } else {
        Object child = role.get(owner);
        if (child == null) {
          DbClass cls = Database.getDbClass(role.getType());
          child = cls.newInstance();
          role.set(owner, child);
        }
        primaryKeyField.set(child, value);
      }
    }

  }

  @Setter
  @Getter
  static class DbClass {
    private final Class<?> type;
    private final DbClass superClass;
    private final List<DbField> fields = new ArrayList<>();
    private final Map<String, DbClass> subClasses = new TreeMap<>();
    private DbSearchMethod primaryKey = null;
    private final Map<String, DbSearchMethod> indices = new TreeMap<>();
    private final List<DbRole> foreignKeys = new ArrayList<>();
    private final List<DbRole> links = new ArrayList<>();
    private final List<DbClass> typeHierarchy = new ArrayList<>();
    private final boolean mapped;
    private DbField version;
    private String label;
    private String name = null;



    @Override
    public String toString() {
      return getName();
    }

    @SuppressWarnings("unchecked")
    private <X extends DbClassInner> List<X> cloneList(DbClass entity, List<X> fields) {
      List<X> result = new ArrayList<>();
      fields.forEach(field -> {
        try {
          X clone = (X) field.clone();
          clone.setEntity(entity);
          result.add(clone);
        } catch (CloneNotSupportedException ex) {
          // ignore
        }
      });
      return result;
    }

    @SuppressWarnings("unchecked")
    private <X extends DbClassInner> Map<String, X> cloneMap(DbClass entity,
        Map<String, X> objects) {
      Map<String, X> result = new TreeMap<String, X>();
      objects.entrySet().forEach(entry -> {
        try {
          X clone = (X) entry.getValue().clone();
          clone.setEntity(entity);
          result.put(entry.getKey(), clone);
        } catch (CloneNotSupportedException ex) {
          // ignore
        }
      });
      return result;
    }

    private DbClass registerSuperClass(CommandScheme commands) throws SQLException {
      DbClass result = null;
      if (type.getSuperclass() != Object.class) {
        DbClass parent = Database.registerDbClass(commands, type.getSuperclass());
        if (parent.isMapped()) {
          fields.addAll(cloneList(this, parent.getFields()));
          indices.putAll(cloneMap(this, parent.getIndices()));
          foreignKeys.addAll(cloneList(this, parent.getForeignKeys()));
          version = parent.getVersion();
          DbClass indirectParent = parent.getSuperClass();
          while (indirectParent != null && indirectParent.isMapped()) {
            indirectParent = indirectParent.getSuperClass();
          }
          result = indirectParent;
        } else {
          fields.addAll(parent.getPrimaryKey().getFields());
          result = parent;
        }
      } else {
        result = null;
      }
      return result;
    }

    private DbRole newRole(Field field, boolean collection) {
      DbRole role = new DbRole();
      role.setEntity(this);
      if (collection) {
        role.setType(getGenericType(field.getGenericType(), 0));
      } else {
        role.setType(field.getType());
      }
      role.setField(field);
      role.setGetter(getGetter(type, field));
      role.setSetter(getSetter(type, field));
      return role;
    }

    private DbField newAttribute(CommandScheme commands, Field field) {
      DbField attribute = new DbField();
      attribute.setEntity(this);
      attribute.setField(field);
      attribute.setGetter(getGetter(type, field));
      attribute.setSetter(getSetter(type, field));
      attribute.setRsGetter(commands.getRsGetter(field.getType()));
      attribute.setStmtSetter(commands.getStmtSetter(field.getType()));
      attribute.setNullable(!field.getType().isPrimitive());
      fields.add(attribute);
      Db db = field.getAnnotation(Db.class);
      if (db != null) {
        if (!db.name().isBlank()) {
          attribute.setName(db.name());
        }
        if (db.size() != 0) {
          attribute.setSize(db.size());
        }
        if (db.scale() != 0) {
          attribute.setScale(db.scale());
        }
      }
      Index[] all = field.getAnnotationsByType(Index.class);
      for (Index index : all) {
        DbSearchMethod path = indices.get(index.value());
        if (path == null) {
          path = new DbSearchMethod();
          path.setEntity(this);
          path.setName(getName() + '_' + index.value());
          indices.put(index.value(), path);
        }
        path.fields.add(attribute);
      }
      return attribute;
    }

    private static DbField initVersion(CommandScheme commands, DbField field) {
      Version version = field.getField().getAnnotation(Version.class);
      if (version != null) {
        field.setIncrementer(commands.getIncrementer(field.getType()));
        field.setVersion(version);
        return field;
      }
      return null;
    }

    private static String getLabel(String name) {
      if (name.length() > 3) {
        return name.substring(0, 3);
      }
      return name;
    }

    private static String nextLabel(String label) throws SQLException {
      String base = label;
      int nr = 0;
      if (label.length() == 4) {
        base = label.substring(0, 3);
        nr = Integer.valueOf(label.substring(3));
        if (nr > 8) {
          throw new SQLException("too many classes start with " + base);
        }
      }
      return base + (++nr);
    }

    private String addSubclass(String label, DbClass subClass) throws SQLException {
      if (superClass != null) {
        label = superClass.addSubclass(label, subClass);
        subClasses.put(label, subClass);
      } else {
        if (this.label == null) {
          this.label = getLabel(getName());
          subClasses.put(this.label, this);
        }
        while (subClasses.containsKey(label)) {
          label = nextLabel(label);
        }
        subClasses.put(label, subClass);
        subClass.setLabel(label);
      }
      return label;
    }

    DbClass getSubclass(String fullName) {
      for (DbClass cls : subClasses.values()) {
        if (cls.getName().equals(fullName)) {
          return cls;
        }
      }
      return null;
    }

    void registerSubclasses() throws SQLException {
      if (superClass != null) {
        this.label = superClass.addSubclass(getLabel(getName()), this);
        Map<String, DbClass> changed = new TreeMap<>();
        Set<String> removedKeys = new TreeSet<>();
        for (Entry<String, DbClass> entry : subClasses.entrySet()) {
          String label = superClass.addSubclass(entry.getKey(), entry.getValue());
          if (!label.equals(entry.getKey())) {
            changed.put(label, entry.getValue());
            removedKeys.add(entry.getKey());
          }
        }
        removedKeys.forEach(key -> subClasses.remove(key));
        changed.forEach((key, value) -> {
          subClasses.put(key, value);
          value.setLabel(key);
        });
      }
    }

    boolean hasSubTypeField() {
      return superClass == null && !subClasses.isEmpty();
    }

    DbField getField(String name) {
      for (DbField field : fields) {
        if (field.getName().equalsIgnoreCase(name)) {
          return field;
        }
      }
      return null;
    }

    DbRole getForeignKey(String name) {
      for (DbRole role : foreignKeys) {
        if (role.getName().equalsIgnoreCase(name)) {
          return role;
        }
      }
      return null;
    }

    List<DbField> getFields() throws SQLException {
      // this is necessary becaus getPrimaryKeys can change the order of fields
      getPrimaryKey();
      return fields;
    }

    DbSearchMethod getPrimaryKey() throws SQLException {
      if (primaryKey == null) {
        primaryKey = new DbSearchMethod();
        primaryKey.setEntity(this);
        primaryKey.setName("pk");
        primaryKey.setUnique(true);
        for (DbField field : getFields()) {
          Id id = field.getField().getAnnotation(Id.class);
          if (id != null) {
            primaryKey.fields.add(field);
            field.setId(id);
            field.setNullable(false);
          }
        }
        for (int i = 0; i < primaryKey.getFields().size(); ++i) {
          DbField field = primaryKey.getFields().get(i);
          getFields().remove(field);
          getFields().add(i, field);
        }
        for (DbRole role : getForeignKeys()) {
          Id id = role.getField().getAnnotation(Id.class);
          if (id != null) {
            role.setId(id);
            DbSearchMethod fk = role.getForeignKey();
            for (DbField field : fk.getFields()) {
              field.setNullable(false);
              primaryKey.getFields().add(field);
            }
          }
        }
      }
      return primaryKey;
    }

    DbRole getLink(String name) {
      for (DbRole role : links) {
        if (role.getName().equalsIgnoreCase(name)) {
          return role;
        }
      }
      return null;
    }

    DbClass(CommandScheme commands, Class<?> cls) throws SQLException {
      type = cls;
      superClass = registerSuperClass(commands);
      mapped = cls.getAnnotation(Mapped.class) != null;
      Db db = cls.getAnnotation(Db.class);
      if (db != null && !db.name().isBlank()) {
        name = db.name();
      }
      for (Field field : cls.getDeclaredFields()) {
        if (field.getAnnotation(DontPersist.class) == null) {
          if (Collection.class.isAssignableFrom(field.getType())) {
            links.add(newRole(field, true));
          } else if (!field.getType().isPrimitive() && !isSupported(field.getType())) {
            foreignKeys.add(newRole(field, false));
          } else if (field.getType().isPrimitive() || isSupported(field.getType())) {
            DbField attribute = newAttribute(commands, field);
            DbField withVersion = initVersion(commands, attribute);
            if (withVersion != null) {
              version = withVersion;
            }
          } else {
            throw new SQLException(
                "Field " + field.getName() + " has unsupported type " + field.getType());
          }
        }
      }
      if (!isMapped()) {
        registerSubclasses();
      }
      ENTITIES.put(cls, this);
    }

    public String getName() {
      if (name == null) {
        return type.getSimpleName();
      }
      return name;
    }

    private static void addSubclass(List<DbClass> list, DbClass cls) {
      if (!list.contains(cls)) {
        DbClass superClass = cls.getSuperClass();
        if (superClass != null) {
          addSubclass(list, cls.getSuperClass());
        }
        list.add(cls);
      }
    }

    List<DbClass> getTypeHierarchy() {
      if (typeHierarchy.isEmpty()) {
        DbClass c = getSuperClass();
        while (c != null) {
          typeHierarchy.add(0, c);
          c = c.getSuperClass();
        }
        typeHierarchy.add(this);
        for (DbClass child : getSubClasses().values()) {
          addSubclass(typeHierarchy, child);
        }
      }
      return typeHierarchy;
    }

    DbClass getRoot() {
      if (superClass != null) {
        return superClass.getRoot();
      }
      return this;
    }

    String getPrimaryKeyAsString(Object object) throws SQLException {
      StringBuilder sb = new StringBuilder();
      for (DbField field : getPrimaryKey().getFields()) {
        Object value = field.get(object);
        if (value != null) {
          sb.append(value).append('|');
        }
      }
      return sb.toString();
    }

    private static Method getGetter(Class<?> cls, Field field) {
      try {
        String name =
            Character.toUpperCase(field.getName().charAt(0)) + field.getName().substring(1);
        if (field.getType() == Boolean.class || field.getType() == boolean.class) {
          return cls.getMethod("is" + name);
        }
        return cls.getMethod("get" + name);
      } catch (NoSuchMethodException | SecurityException ex) {
        return null;
      }
    }

    private static Method getSetter(Class<?> cls, Field field) {
      try {
        String name =
            Character.toUpperCase(field.getName().charAt(0)) + field.getName().substring(1);
        return cls.getMethod("set" + name, field.getType());
      } catch (NoSuchMethodException | SecurityException ex) {
        return null;
      }
    }

    public Object newInstance() throws SQLException {
      try {
        return getType().getConstructor().newInstance();
      } catch (Exception ex) {
        if (ex.getCause() != null) {
          throw new SQLException(ex.getCause());
        }
        throw new SQLException(ex);
      }
    }

    public int[] getPkFieldNumbers() throws SQLException {
      int[] result = new int[getPrimaryKey().getFields().size()];
      for (int i = 0; i < result.length; ++i) {
        result[i] = i + 1;
      }
      return result;
    }

  }

  private static Map<Class<?>, DbClass> ENTITIES = new HashMap<>();
  private final Supplier<CommandScheme> commandsCreator;

  public Database() {
    this(() -> new CommandScheme());
  }

  public Database(Supplier<CommandScheme> commandSupplier) {
    commandsCreator = commandSupplier;
  }

  private static boolean isSupported(Class<?> cls) {
    return Arrays.stream(SUPPORTED_OBJECT_TYPES).anyMatch(c -> c == cls);
  }

  private CommandScheme getCommands(Connection connection) throws SQLException {
    CommandScheme result = COMMAND_SCHEMES.get(connection);
    if (result == null) {
      result = commandsCreator.get();
      COMMAND_SCHEMES.put(connection, result);
      connection.setAutoCommit(false);
    }
    return result;
  }

  static DbClass getDbClass(Class<?> cls) {
    return ENTITIES.get(cls);
  }

  static DbClass registerDbClass(CommandScheme commands, Class<?> cls) throws SQLException {
    DbClass dbc = ENTITIES.get(cls);
    if (dbc == null) {
      dbc = new DbClass(commands, cls);
      ENTITIES.put(cls, dbc);
    }
    return dbc;
  }

  /**
   * Commits a transaction It is advised to use
   * {@link com.palisand.bones.persist.Database#transaction(Connection, Transaction)} or
   * {@link com.palisand.bones.persist.Database#transactionWithResult(Connection, TransactionWithResult)}
   * 
   * @param connection the connection used for the transaction
   * @throws SQLException
   */
  public void commit(Connection connection) throws SQLException {
    connection.commit();
    CommandScheme commands = getCommands(connection);
    commands.clearCache();
  }

  /**
   * Commits a transaction It is advised to use
   * {@link com.palisand.bones.persist.Database#transaction(Connection, Transaction)} or
   * {@link com.palisand.bones.persist.Database#transactionWithResult(Connection, TransactionWithResult)}
   * 
   * @param connection the connection used for the transaction
   * @throws SQLException
   */
  public void rollback(Connection connection) throws SQLException {
    connection.rollback();
  }

  /**
   * With this methods you can register the persistent classes. This method should be called before
   * any other methods of database are used.
   * 
   * @param connection the jdbc connection
   * @param persistentClasses the persistent classes that are mapped to database tables
   * @throws SQLException
   */
  public void register(Connection connection, Class<?>... persistentClasses) throws SQLException {
    CommandScheme commands = getCommands(connection);
    for (Class<?> c : persistentClasses) {
      Database.registerDbClass(commands, c);
    }
  }

  /**
   * This method verifies if all tables are up to date with the definition of the classes This
   * method will register the given classes as well so, you do not have to do this explicitely if
   * you use this method
   * 
   * @param connection A valid database connection
   * @param persistentClasses the persistent classes
   * @return true if the database tables are consistent with the persistent classes
   * @throws SQLException
   */
  public boolean verify(Connection connection, Class<?>... persistentClasses) throws SQLException {
    String error = "Database.verify error";
    CommandScheme commands = getCommands(connection);
    Consumer<String> logger = commands.getLogger();
    try {
      commands.logger(str -> {
        if (logger != null)
          logger.accept("Verification Error: " + str);
        throw new RuntimeException(error);
      });
      upgrade(connection, persistentClasses);
      return true;
    } catch (RuntimeException ex) {
      if (ex.getMessage().equals(error)) {
        return false;
      }
      throw ex;
    } finally {
      commands.logger(logger);
    }
  }

  /**
   * This method upgrades the tables in the database so they will be consistent with the given
   * persistent classes This method will detect and create missing classes, fields, indices and
   * foreign keys. It will not detect type changes or nullable changes. It will also drop tables,
   * fields, indices and foreign keys that are not specified in the classes.
   * 
   * @param connection a valid database connection
   * @param persistentClasses the persistent classes
   * @throws SQLException
   */
  public void upgrade(Connection connection, Class<?>... persistentClasses) throws SQLException {
    register(connection, persistentClasses);
    CommandScheme commands = getCommands(connection);
    HashSet<DbRole> fks = new HashSet<>();
    List<DbClass> withParents = new ArrayList<>();
    Set<String> tableNames = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
    for (Class<?> type : persistentClasses) {
      DbClass dbc = Database.getDbClass(type);
      if (!dbc.isMapped()) {
        tableNames.add(dbc.getName());
      }
    }
    Metadata metadata = commands.getMetadata(connection);
    TreeSet<String> tablesRemoved = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
    tablesRemoved.addAll(metadata.getTables().keySet());
    for (DbTable table : metadata.getTables().values()) {
      for (DbIndex fk : table.getForeignKeys().values()) {
        if (!tableNames.contains(fk.getReferences().getName())) {
          commands.dropContraint(connection, table.getName(), fk.getName());
        }
      }
    }
    for (Class<?> type : persistentClasses) {
      DbClass entity = getDbClass(type);
      if (!entity.isMapped()) {
        if (entity.getSuperClass() != null) {
          withParents.add(entity);
        }
        commands.upgradeTable(connection, metadata.getTables().get(entity.getName()), entity);
        tablesRemoved.remove(entity.getName());
        fks.addAll(entity.getForeignKeys());
      }
    }
    for (DbClass cls : withParents) {
      DbTable table = metadata.getTables().get(cls.getName());
      commands.upgradeParent(connection, table, cls);
    }
    for (DbRole role : fks) {
      DbTable table = metadata.getTables().get(role.getEntity().getName());
      commands.upgradeForeignKey(connection, table, role);
    }
    for (String name : tablesRemoved) {
      commands.dropTable(connection, name);
    }

  }

  /**
   * Drop all tables from the schema/database that the given connection connects to.
   * 
   * @param connection A valid connection
   * @throws SQLException
   */
  public void dropAll(Connection connection) throws SQLException {
    CommandScheme commands = getCommands(connection);
    Metadata md = commands.getMetadata(connection);
    for (DbTable table : md.getTables().values()) {
      for (DbIndex fk : table.getForeignKeys().values()) {
        commands.dropContraint(connection, table.getName(), fk.getName());
      }
    }
    for (DbTable table : md.getTables().values()) {
      commands.dropTable(connection, table.getName());
    }
  }

  /**
   * Insert a persist object in the database. When the class of the object has generated primary key
   * fields, the result will have those field initialised with the value generated by the database.
   * It is not garantueed that the return value is the same instance as the object parameter.
   * 
   * @param <T> one of the persistent classes
   * @param connection a valid connection
   * @param object the object to insert. Should be one of the registered classes
   * @return the inserted object
   * @throws SQLException
   */
  @SuppressWarnings("unchecked")
  public <T> T insert(Connection connection, T object) throws SQLException {
    CommandScheme commands = getCommands(connection);
    DbClass entity = getDbClass(object.getClass());
    return (T) commands.insert(connection, entity, entity.getLabel(), object);
  }

  /**
   * Updates a persistent object. When the object has a version field, it will increment the field
   * if the operation succeeds. The return value may be a different instance if the instance was
   * cached in an earlier operation within this transaction
   * 
   * @param <T> the type of the object
   * @param connection a valid connection
   * @param object the object to update. Should be an instance of one of the registered classes
   * @return
   * @throws SQLException
   * @throws StaleObjectException if the version of the object is not correct
   */
  @SuppressWarnings("unchecked")
  public <T> T update(Connection connection, T object) throws SQLException {
    CommandScheme commands = getCommands(connection);
    DbClass entity = getDbClass(object.getClass());
    return (T) commands.update(connection, entity, object);
  }

  /**
   * Deletes the given object from the database. Only the Id and Version fields of the object are
   * used. Any other fields are not used in the method
   * 
   * @param connection a valid connection
   * @param object an instance of one of the registered persistent classes
   * @throws SQLException
   * @throws StaleObjectException if the version of the object is not correct
   */
  public void delete(Connection connection, Object object) throws SQLException {
    CommandScheme commands = getCommands(connection);
    DbClass entity = getDbClass(object.getClass());
    commands.delete(connection, entity, object);
  }

  /**
   * Resets the fields of the given object to the values in the database. The primary key of the
   * object is used to find the right row. The return value may be a different instance then the
   * object parameter
   * 
   * @param <T>
   * @param connection
   * @param object
   * @return
   * @throws SQLException
   */
  @SuppressWarnings("unchecked")
  public <T> T refresh(Connection connection, T object) throws SQLException {
    if (object == null)
      return null;
    CommandScheme commands = getCommands(connection);
    DbClass cls = Database.getDbClass(object.getClass());
    return (T) commands.refresh(connection, cls, object);
  }

  /**
   * Get the database name of the session of this connection
   * 
   * @param connection a valid connection
   * @return the name of the database
   * @throws SQLException
   */
  public String getDatabaseName(Connection connection) throws SQLException {
    CommandScheme commands = getCommands(connection);
    return commands.getDatabaseName(connection);
  }

  /**
   * returns a new {@link com.palisand.bones.persist.Query} object
   * 
   * @param <X> A type reflecting the type of types of object(s) returned by this query
   * @param connection a valid connection
   * @param queryType type class of X
   * @return a query initialised for the given queryType
   * @throws SQLException
   */
  public <X> Query<X> newQuery(Connection connection, Class<X> queryType) throws SQLException {
    return newQuery(connection, queryType, null);
  }

  /**
   * returns a new {@link com.palisand.bones.persist.Query} object with an explicit alias for X that
   * should be a persistent class in this case
   * 
   * @param <X> the persistent class you want to select
   * @param connection a valid connection
   * @param queryType the class of X
   * @param alias the alias used in the query for X
   * @return a query initialised to select objects of type X
   * @throws SQLException
   */
  public <X> Query<X> newQuery(Connection connection, Class<X> queryType, String alias)
      throws SQLException {
    CommandScheme commands = getCommands(connection);
    Query<X> query = new Query<>(connection, commands, queryType);
    if (queryType.isRecord()) {
      for (RecordComponent comp : queryType.getRecordComponents()) {
        if (!isSupported(comp.getType()) && !comp.getType().isPrimitive()) {
          query.select(comp.getType(), comp.getName());
        }
      }
    } else if (!isSupported(queryType)) {
      return query.select(queryType, alias);
    }
    return query;
  }

  /**
   * executes a transaction and returns a result from the transaction. The transaction action is
   * committed when the Transaction is successful and rollbacked in case of an exception
   * 
   * @param connection a valid transaction
   * @param transaction the operations of the transaction with a lambda function
   * @return the object returned in the lambda function
   * @throws SQLException
   */
  public Object transactionWithResult(Connection connection, TransactionWithResult transaction)
      throws SQLException {
    try {
      Object result = transaction.perform();
      commit(connection);
      return result;
    } catch (SQLException ex) {
      rollback(connection);
      throw ex;
    } catch (Exception ex) {
      rollback(connection);
      throw new SQLException(ex);
    }
  }

  /**
   * executes a transaction. The transaction action is committed when the Transaction is successfull
   * and rollbacked in case of an exception
   * 
   * @param connection
   * @param transaction
   * @throws SQLException
   */
  public void transaction(Connection connection, Transaction transaction) throws SQLException {
    try {
      transaction.perform();
      commit(connection);
    } catch (SQLException ex) {
      rollback(connection);
      throw ex;
    } catch (Exception ex) {
      rollback(connection);
      throw new SQLException(ex);
    }
  }

}
